---
title: "Data cleaning"
author: Eric Torres, Luc√≠a de Lamadrid, Konstantina Gkopi.
format:
  html:
    embed-resources: true
editor: visual
---

### 1. Load packages

```{r}
#| message: false 
#| echo: false
rm(list=ls())
library(tidyverse) 
library(readr)
```

## 2. Read data

```{r}
metadata_df <- read.table('../data/01_data_metadata.tsv', header=TRUE, sep='\t')
head(metadata_df)
```

We are going to check if there are missing values (NA):

```{r}
na_check <- anyNA(metadata_df)
na_check
```

Is the value relative abundance? It is, as the total value of each row is 1.

```{r}
otu_columns <- select(metadata_df, starts_with("OTU"))
row_sums <- rowSums(otu_columns)
summary(row_sums)
```

A dataset is tidy when:

-   Each variable is a column

-   Each observation is a row

-   Each value is a cell

In the dataset we are working with, there are columns (`OTU0`- `OTU-6695`) in which the column names are one variable (`OTU`) and the cell values are another variable (`rel_abundance`). To do some tidying, we are going to use `pivot_longer()`:

```{r}
metadata_df_long <- metadata_df |> 
  pivot_longer(
    cols = starts_with("OTU"), 
    names_to = "OTU", 
    values_to = "rel_abundance"
  )

dim(metadata_df_long)
```

As a result, we get a dataframe of $N = 4,519,800$ !

**Exploring OTU Abundance Distributions and Determining Filtering Thresholds**

To reduce the size of the dataset from the original $N = 4,519,800$ rows and focus on meaningful OTUs, we apply filtering to remove low-abundance and negligible contributors.

We calculated the mean relative abundance of each OTU, ranked them in descending order, computed their cumulative contribution to total abundance, and plotted a cumulative contribution curve to identify key OTUs contributing significantly to the microbiome.

```{r}
# Calculate cumulative contribution
cumulative_otus <- metadata_df_long |>
  group_by(OTU) |>
  summarize(mean_abundance = mean(rel_abundance)) |>
  arrange(desc(mean_abundance)) |>
  mutate(cumulative_abundance = cumsum(mean_abundance) / sum(mean_abundance))

head(cumulative_otus)

# Plot cumulative contribution
ggplot(cumulative_otus, aes(x = reorder(OTU, -mean_abundance), y = cumulative_abundance, group = 1)) +
  geom_line() +
  geom_hline(yintercept = 0.95, linetype = "dashed", color = "red") +
  geom_hline(yintercept = 0, color = "black", linetype = "solid") +   # Add x-axis
  geom_vline(xintercept = 0, color = "black", linetype = "solid") +   # Add y-axis
  labs(title = "Cumulative Contribution of OTUs", x = "OTU (Ranked by Abundance)", y = "Cumulative Abundance") +  
theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()
)

```

We are going to keep the OTUs that made up until 95% of all the cumulative abundance. There are many OTUs that are very little represented, and so they hardly add nothing to the cumulative abundance. Those are the ones we are getting rid of:

```{r}
# Filter OTUs contributing to 95% cumulative abundance
otus_to_keep <- cumulative_otus |>
  filter(cumulative_abundance <= 0.95) |>
  pull(OTU)

# Filter the metadata to retain only these OTUs
filtered_metadata <- metadata_df_long |>
  filter(OTU %in% otus_to_keep)

filtered_metadata
```

As a result, we get a data frame of $N = 264,600$ !

```{r}
# Number of OTUs before filtering
n_total_otus <- n_distinct(metadata_df_long$OTU)

# Number of OTUs after filtering
n_filtered_otus <- n_distinct(filtered_metadata$OTU)

# Print results
cat("Number of OTUs before filtering:", n_total_otus, "\n")
cat("Number of OTUs after filtering:", n_filtered_otus, "\n")
cat("Number of OTUs removed:", n_total_otus - n_filtered_otus, "\n")
cat("Percentage of OTUs removed:", (n_total_otus - n_filtered_otus) * 100 / n_total_otus, "% \n")

```

Filtering down from **6,696 OTUs to 392** (removing **6,304 OTUs**) might seem like a large loss, but this is often expected in microbiome datasets due to the nature of the data.

We check the distribution of OTU relative abundances to understand the range and frequency of abundance values after having filter them.

```{r}
# Distribution of OTU relative abundances
ggplot(filtered_metadata, aes(x = rel_abundance)) +
  geom_histogram(bins = 50, fill = "skyblue", alpha = 0.7) +
  scale_x_log10() +
  labs(title = "Distribution of OTU Relative Abundances", x = "Relative Abundance (Log Scale)", y = "Frequency") +
  theme_minimal()

```

Filter stricter because the distribution shows a large number of OTUs with extremely low relative abundances, likely representing noise or negligible contributors.

```{r}
# Set the stricter abundance threshold
abundance_threshold <- 1e-6
# Apply the threshold to filter OTUs
filtered_metadata_stricter <- filtered_metadata |>
  filter(rel_abundance >= abundance_threshold)
filtered_metadata_stricter

```

As a result, we get a data frame of $N = 65,938$ !

```{r}
# Plot the distribution of relative abundances after stricter filtering
ggplot(filtered_metadata_stricter, aes(x = rel_abundance)) +
  geom_histogram(bins = 50, fill = "skyblue", alpha = 0.7) +
  scale_x_log10() +
  labs(title = "Distribution of OTU Relative Abundances", x = "Relative Abundance (Log Scale)", y = "Frequency") +
  theme_minimal()

```

We can replace the numeric codes with descriptive labels. This includes variables such as Sex or Diet. To do so, we need the dictionary dataframe:

```{r}
dictionary_df <- read.table('../data/01_data_dictionary.tsv', header=FALSE, sep='\t')
```

```{r}
head(dictionary_df)
```

```{r}
dictionary_long <- dictionary_df |> 
  mutate(Column = ifelse(grepl("^[A-Za-z]", V1), V1, NA)) |> 
  fill(Column, .direction = "down") |> 
  filter(!is.na(V2)) |> 
  filter(!V1 == Column) |> 
  rename(Value = V1, Label = V2) |> 
  select(Column, Value, Label)
```

```{r}
dictionary_long
```

As the dataset still contains a large number of rows, the process is taking a long time. Therefore, I created a subset with only a thousand rows and performed the label substitution to verify if the code works. It does! Once we finalize the dataset, we can apply the changes to the entire data and create the new dataset `metadata_df_long_label`.

```{r}
metadata_mil <- metadata_df_long[1:1000,]
dim(metadata_mil)
```

```{r}
columns_to_replace <- unique(dictionary_long$Column)

for (col in columns_to_replace) {
  column_dict <- dictionary_long |> filter(Column == col)
    
  # Sustituir los valores en la columna principal
  metadata_mil[[col]] <- sapply(metadata_mil[[col]], function(x) {
   label <- column_dict |> filter(Value == x) |> pull(Label)
    if (length(label) > 0) label else x # Reemplazar si hay etiqueta, sino mantener original
  })
}
```

```{r}
metadata_mil
```

It is clear that the primary key of `metadata_df` is a combination of all the columns. We can add a surrogate key for clearly identifying each observation.
